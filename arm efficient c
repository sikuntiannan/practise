http://www.davespace.co.uk/arm/efficient-c-for-arm/
核心思想：程序就是代码，严格遵守代码要求。所以不应期待编译器会帮自己省。
浮点也比较慢，对应的可以使用定点
少用除法，因为慢
模也同样慢，可以将其换成乘法；
使用无符号操作，避免符号处理。
不使用环绕计数器：array[n%9]这样的东西。
考虑下查表。
模和除是一个命令，这两个结果可以用汇编同时拿到。：计算操作会有很多状态位被置位
 数据要对齐，没有对齐的数据读取时一次只能读一个字节，那么一个long int 就要读8次，对齐的情况就只有一次
 参数传递时，传一个bool和一个long int(int,取决于平台)用的空间是一样的，都是一个寄存器，c++中有些参数传递不在寄存器中传递，在内存中传递，寄存器传一个指针，指向参数所在的内存，函数自己通过参数去获取参数。使用位操作来合并多个bool。
 c标准保证成员安装指定的顺序布局，而结构体有内存对齐，所以布局顺序的改变可以减小结构体的大小，提高内存填充的效率
 循环中一直用的东西，把它拿到循环外定义和赋值，这样在循环内就不会多次计算，其实整形的逻辑或者加减（单项式）没有很大意义。
 尽量把数据存在容器中，而不是和指令缠绕在一起，可以减小程序的大小
 在循环中遍历数组不要使用索引，而是直接拷贝数组地址，之后++和判结尾就可以，这样少了基地址＋偏移这个步骤
 指针访问，如果有多次，应建立本地缓存，否则cpu为保证一致性，会多次加载。因为CPU不能保证这个指针指向的值只有自己这个核在使用，所以要重新加载
 指针链，可以加一个指针的局部缓存
int search2(int *list, int N, int want)
{
  int i;

  list[N] = want;

  i = 0;
  while (list[i] != want)
    i++;

  if (i == N)
    return -1;

  return i;
}
int search1(int *list, int N, int want)
{
  int i;

  for (i = 0; i < N; i++)
    if (list[i] == want)
      return i;

  return -1;
}
这两个代码，同样的功能，少N次比较，不打断流水线
循环展开应该参照：达夫机：
int  main()
{
    int  n  = 0 ;
    switch  (n)  { //这里
    case 0 :  do   {cout  <<   " 0 "   <<  endl;//这里
    case 1 :         cout  <<   " 1 "   <<  endl;
    case 2 :         cout  <<   " 2 "   <<  endl;
    case 3 :         cout  <<   " 3 "   <<  endl; 
      }   while ( -- n  > 0 ); //这里
   } 
}

并且：int countbits2(unsigned int N)
{
  int nbits = 0;
  while (N) {
    if (N & 1) nbits++;
    if (N & 2) nbits++;
    if (N & 4) nbits++;
    if (N & 8) nbits++;
    N >>= 4;
  }
  return nbits;
}这个代码不是这个需求的最优，	
	a = ((a & 0xAAAA) >> 1) + (a & 0x5555);0101 0101 0101 0101
	a = ((a & 0xCCCC) >> 2) + (a & 0x3333);0011 0011 0011 0011
	a = ((a & 0xF0F0) >> 4) + (a & 0x0F0F);0000 1111 0000 1111
	a = ((a & 0xFF00) >> 8) + (a & 0x00FF);0000 0000 1111 1111
  考虑机器运算器和寄存器的位数，实际运算时使用的都是机器自然大小，而不是代码声明的大小。
内存访问看的不懂------------
因为处理器始终是用机器大小来运算，所以不要使用char short这种不是机器大小的类型，机器大小就是64或者32。
这里会有数据扩展，从8位到64位...
  for (char i = 0; i < 64; i++)
  {
    sum += l[i];
  }
  这个循环的效率优于，猜测是因为缓存大小问题
  for (int i = 0; i < 64; i++)
  {
    sum += l[i];
  }
  且 sum与l[]类型相同时最优，把一个数据置零用的异或命令不是直接赋值，
  不要混用不同编译器生成的程序或者库
  使用地址访问变量，这个变量就是内存绑定，它不会再寄存器或者缓存中缓存，每次都会从内存加载，使用完后就立刻保存
  循环条件使用倒计时可以减小开销，因为减去一个值会设置状态位（是否大于零）这样就可以不用和零比较
  编译器尽量的把局部变量存在不同的寄存器中，并且对不重复使用的变量使用相同寄存器存储，但当局部变量数量超过寄存器时就把多余的存在堆栈上，多出的变量的访问速度就会减慢，而这实在是太底层了，动辄一个容器就超了。
  函数调用，在寄存中传递有限个参数，其余的在堆栈中传递，所以使用不超过4个参数可以避免堆栈
  如果函数和调用方在同一个文件中，那么编译器会进一步优化：内联或者不保存未使用的寄存器
  可以对立即数编码，但不能对常量编码
  c -= 0xE00;
return c == (UNICODE_THAI_MAI_HAN_AKAT  - 0xE00) ||
       c == (UNICODE_THAI_SARA_AM       - 0xE00) ||
       c == (UNICODE_THAI_SARA_I        - 0xE00) ||.....
       这是个高效的写法
减少分支：
int insideRange2(int v, int min, int max)
{
  return (unsigned) (v - min) < (max - min);一个分支
}
int insideRange1(int v, int min, int max)
{
  return v >= min && v < max;两个分支
}
将全局变量尽可能的集中到一个数组中，这样允许通过一个指针和一个偏移来访问，而不是很多个指针来访问