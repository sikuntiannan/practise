array<T,2>实际上不是两个长度，是三个。最后一个是0，实际上是end()。这个是visual studio 2017的实现。
《---------------------------------》
内存部分，主要根据电脑内存的大小来使用，最前面的部分操作系统并没有使用。0x0000 00FE 0DCF FB58，最前面有六个0，也就是有40位是有效地址，其中我的内存是32G也就是
 0x8 0000 0000
0xFE 0DCF FB58
对比看的话就是1111 1110
                               0000 1000
反之，假设我的内存是32G，可以插4条，那么就是：0x80 0000 0000
                                          0xFE 0DCF FB58   貌似这时候最大的单条内存就是32G。存储地址可根据服务器内存的实际大小来压缩那一两个字节。压缩的办法就是64位内存地址的前几位都是零，可以存储时
                                          不保存前面的零，只保留后面的有效地址，使用时再补齐。用char存储，虽然实际加载时还是加载64位但同样大小的内存可以存储的地址更多，但效率会第。
《-----------------------------------------》
shared_ptr这个东西可以像java内存泄漏那样写，也会导致c++内存泄漏。智能指针不仅仅用来管理内存，更重要的是可以管理连接，文件连接、···这是其他语言没有的。
应该和weak_ptr一起使用，来避免循环引用和访问已释放的对象，已释放的对象的意思是：这个对象有它的管理者和使用者，管理者已经放弃管理，此时应该释放对象，但由于使用者保留了指针导致管理者实际上没有释放对象，，
这和管理者这个类的设计有冲突，并且没回回收内存，也是一种形式上的内存泄露。
《-------------------------------------------------》
template<class T,size_t L> void sum(T aim[L]){}
《-------------------------------------------------------------》
数组删除时可以先把它换到最后然后再删除，这样的复杂度只有1，但直接删是N。
